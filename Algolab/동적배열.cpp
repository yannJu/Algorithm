/*
배열(Array)은 가장 기본이 되는 선형 자료구조이다. 배열은 일반적으로 고정된 크기를 가지기 때문에 처음 할당한 크기보다 많은 데이터를 배열에 추가할 수 없다. 
이러한 단점을 보완하기 위해 쿠민이는 원소의 수에 따라 배열의 크기를 조절하는 동적 배열을 만들려고 한다. 
쿠민이가 만드는 동적 배열의 규칙은 아래와 같다.
 1. 모든 배열의 처음 크기는 ‘0’ 이다.
 2. 원소가 추가될 때, 추가될 원소를 포함한 전체 원소의 수가 배열의 크기보다 작거나 같은 경우 기존
배열에 원소를 추가한다.
 3. 원소가 추가될 때, 추가될 원소를 포함한 전체 원소의 수가 배열의 크기를 넘는 경우 새로운 배열을
만들고 값을 복사한다. 이때, 새로 만든 배열의 크기는 전체 원소 수보다 큰 2의 거듭제곱 수 중 가장 작은 값으로 한다. 
이때, 배열의 번호와 해당 배열에 추가할 원소의 수가 입력으로 주어질 때, 원소가 복사된 횟수를 계산하는 프로그램을 작성하시오.
‘2 9’, ‘6 2’, ‘2 5’, ‘2 10’, ‘6 31’ 5개의 입력이 주어질 때, 위 규칙에 의해 아래와 같이 동작한다.
 1. 2번 배열에 9개 원소 추가. 2번 배열의 크기는 0 이므로 16 (9보다 큰 가장 작은 2의 거듭제곱 수)
크기의 배열 생성 후 원소 추가. 이때, 기존 2번 배열에 저장돼 있던 원소가 없으므로 값 복사 없음.
 2. 6번 배열에 2개 원소 추가. 6번 배열의 크기는 0 이므로 4 (2보다 큰 가장 작은 2의 거듭제곱 수) 크기의 배열 생성 후 원소 추가.
  이때, 기존 6번 배열에 저장돼 있던 원소가 없으므로 값 복사 없음.
 3. 2번 배열에 5개 원소 추가. 2번 배열의 5개 원소를 추가할 때, 전체 원소 수는 14개로 할당된 배열의 크기 16보다 작으므로 추가 작업 없이 배열에 원소 추가.
 4. 2번 배열에 10개 원소 추가. 2번 배열의 10개 원소를 추가할 때, 전체 원소 수는 24개로 할당된 배열의 크기 16보다 크므로, 32 크기의 새로운 배열을 만든 후 기본 배열에 있던 14개를 복사. 이후
새로운 10개의 원소 추가.
 5. 6번 배열에 31개 원소 추가. 6번 배열의 31개 원소를 추가할 때, 전체 원소 수는 33개로 할당된 배열의 크기 4보다 크므로, 64 크기의 새로운 배열을 만든 후 기본 배열에 있던 2개를 복사. 이후 새로운 31개의 원소 추가. 따라서 복사된 원소의 총 개수는 16(=14 + 2) 가 된다. 
 
 입력
입력은 표준입력(standard input)을 사용한다. 첫 번째 줄에는 테스트 케이스 개수를 나타내는 t (2 ≤ t ≤30)가 입력된다. 
두 번째 줄부터는 각 테스트 케이스에 대한 입력이 주어진다. 각 테스트 케이스의 첫 번째 줄에는 데이터 입력 횟수 n (1 ≤ n ≤ 10,000) 이 주어진다. 두 번째 줄부터 n
개의 줄에 걸쳐 배열의 번호와 입력될 데이터의 수 a 와 c (1 ≤ a ≤ 100, 1 ≤ c ≤ 5,000) 가 공백을 기준으로 순서대로 주어진다. 

출력
출력은 표준출력(standard output)을 사용한다. 출력의 첫 줄에 복사된 원소의 총 개수를 출력한다.
입출력 예
입력 출력 

2
5
2 9
6 2
2 5
2 10
6 31 
7
1 1
1 1
1 1
1 2
1 4
1 7
1 1

16
26
*/

#include <iostream>
#include <vector>
#include <cmath>
#define pii pair<int, int>
using namespace std;

int main() {
    int testC;

    cin >> testC;
    while(testC--) {
        int n, result = 0;
        vector<pii> v(100, make_pair(0, 0)); //first : 배열크기, second : 원소수
        
        cin >> n;
        for (int i = 0; i < n; i++) {
            int a, b;
            cin >> a >> b;

            if (v[a - 1].first < v[a - 1].second + b) {
                int nextSz = log2(v[a - 1].second + b) + 1;
                nextSz = pow(2, nextSz);

                result += v[a - 1].second;
                v[a - 1].first = nextSz; 
            }
            v[a - 1].second += b;
        }

        cout << result << endl;
    }
}